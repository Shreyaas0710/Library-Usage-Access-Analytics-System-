{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Analyze Auditorium Dataset</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&family=Orbitron:wght@600&display=swap');

:root {
  --primary-color: #6c5ce7;
  --secondary-color: #00cec9;
  --accent-color: #fd79a8;
  --dark-color: #2d3436;
  --light-bg: #e3f0ff;
  --light-primary: #ffffff;
  --card-bg: rgba(255,255,255,0.98);
  --chart-bg: #f3fafd;
  --border-color: #b3d8fd;
  --shadow-color: rgba(0,0,0,0.07);
  --error-color: #d63031;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Montserrat', sans-serif;
  background: linear-gradient(135deg, #e3f0ff 0%, #b3d8fd 100%);
  color: var(--dark-color);
  min-height: 100vh;
  padding: 2rem;
  line-height: 1.6;
}

/* Heading style */
h1 {
  font-family: 'Orbitron', sans-serif;
  text-align: center;
  margin-bottom: 2rem;
  color: var(--primary-color);
  font-size: 2.5rem;
  letter-spacing: 2px;
  text-shadow: 1px 1px 4px rgba(0,0,0,0.08);
}

/* Container styles */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  background-color: var(--card-bg);
  border-radius: 20px;
  box-shadow: 0 4px 12px var(--shadow-color);
  border: 1px solid var(--border-color);
}

/* Form groups */
.form-group {
  margin-bottom: 1.5rem;
  position: relative;
}

/* Labels */
label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--dark-color);
}

/* Inputs and select */
input[type="date"], select {
  width: 100%;
  padding: 0.8rem 1rem;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: #f3fafd;
  font-family: 'Montserrat', sans-serif;
  font-size: 1rem;
  color: var(--dark-color);
  transition: box-shadow 0.3s, border-color 0.3s;
}

input[type="date"]:focus, select:focus {
  outline: none;
  border-color: var(--secondary-color);
  box-shadow: 0 0 8px rgba(0,206,201,0.13);
}

/* Select arrow styling */
select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%232d3436' viewBox='0 0 24 24'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 1rem center;
  background-size: 1rem;
}

/* Button styles */
button {
  width: 100%;
  padding: 1rem 2rem;
  background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
  color: #fff;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-family: 'Orbitron', sans-serif;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 2rem;
  box-shadow: 0 4px 12px rgba(108,92,231,0.13);
  letter-spacing: 1px;
  text-transform: uppercase;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(108,92,231,0.18);
}

button:active {
  transform: translateY(1px);
}

button:disabled {
  background: linear-gradient(45deg, #b3d8fd, #e3f0ff);
  color: #888;
  cursor: not-allowed;
  box-shadow: none;
}

/* Error message styling */
#error-message {
  color: var(--error-color);
  margin-top: 1rem;
  text-align: center;
  font-weight: 600;
}

/* Chart container styling */
#chart-container {
  margin-top: 2rem;
  background-color: var(--chart-bg);
  border-radius: 15px;
  padding: 2rem;
  border: 1px solid var(--border-color);
  box-shadow: inset 0 0 20px rgba(179,216,253,0.07);
  position: relative;
  overflow: hidden;
  transition: box-shadow 0.3s;
  height: 500px;
}

#chart-container::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; height: 4px;
  background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
  border-radius: 4px 4px 0 0;
}

/* Canvas styling */
canvas {
  width: 100% !important;
  height: 100% !important;
}

/* Offline notice styling */
.offline-notice {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  background-color: var(--error-color);
  color: #fff;
  padding: 0.75rem 1.5rem;
  border-radius: 5px;
  box-shadow: 0 3px 10px rgba(0,0,0,0.2);
  display: none;
  z-index: 1000;
}

/* Responsive tweaks */
@media(max-width:768px){
  body {
    padding: 1rem;
  }
  h1 {
    font-size: 2rem;
  }
  #chart-container {
    padding: 1rem;
  }
}
</style>
</head>
<body>
<div class="offline-notice" id="offline-notice">You are currently offline. Some features may be limited.</div>

<div class="container">
  <h1>{{ dataset_name }}</h1>

  <!-- Attribute Count Selector -->
  <div class="form-group">
    <label for="attribute-count">Number of Attributes to Visualize</label>
    <select id="attribute-count">
      {% for i in range_values %}
        <option value="{{ i }}">{{ i }}</option>
      {% endfor %}
    </select>
  </div>

  <!-- Attribute Selectors -->
  <div id="attribute-selectors"></div>

  <!-- Chart Type Selector -->
  <div class="form-group">
    <label for="chart-type">Select Chart Type</label>
    <select id="chart-type">
      <option value="bar">Bar Chart</option>
      <option value="line">Line Chart</option>
      <option value="pie">Pie Chart</option>
      <option value="doughnut">Doughnut Chart</option>
      <option value="radar">Radar Chart</option>
      <option value="polarArea">Polar Area Chart</option>
    </select>
  </div>

  <!-- Generate Button -->
  <button id="generate-btn">Generate Visualization</button>
  <div id="error-message"></div>

  <!-- Chart Container -->
  <div id="chart-container">
    <canvas id="chartCanvas"></canvas>
  </div>
</div>

<script>
  // Online/offline status handling
  function updateOnlineStatus() {
    const offlineNotice = document.getElementById('offline-notice');
    if (!navigator.onLine) {
      offlineNotice.style.display = 'block';
      // If you have cached data, you can load it here
      if (localStorage.getItem('lastDataset')) {
        const cachedData = JSON.parse(localStorage.getItem('lastDataset'));
        renderChart(cachedData.data);
      }
    } else {
      offlineNotice.style.display = 'none';
    }
  }

  window.addEventListener('online', updateOnlineStatus);
  window.addEventListener('offline', updateOnlineStatus);
  updateOnlineStatus();

  const fields = {{ fields|safe }} || [];
  const datasetName = "{{ dataset_name }}" || "Dataset Visualizer";

  const attributeCountSelect = document.getElementById('attribute-count');
  const attributeSelectorsDiv = document.getElementById('attribute-selectors');
  const generateBtn = document.getElementById('generate-btn');
  const chartCanvas = document.getElementById('chartCanvas');
  const errorMessage = document.getElementById('error-message');

  let currentChart = null;

  // Helper: Detect potential date fields in dataset
function getPotentialDateFields(dataSample) {
  const dateFields = [];
  if (!dataSample) return dateFields;
  for (const key in dataSample) {
    if (typeof dataSample[key] === 'string') {
      const dateStr = dataSample[key];
      // Try to parse date
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        // Basic check: string length and format
        if (dateStr.includes('T') || dateStr.match(/^\d{4}-\d{2}-\d{2}/)) {
          dateFields.push(key);
        }
      }
    }
  }
  return dateFields;
}

// Render attribute selectors
function renderAttributeSelectors(count) {
  attributeSelectorsDiv.innerHTML = '';
  errorMessage.textContent = '';

  for (let i = 0; i < count; i++) {
    const group = document.createElement('div');
    group.className = 'form-group';

    const label = document.createElement('label');
    label.textContent = `Attribute ${i + 1}`;
    group.appendChild(label);

    const select = document.createElement('select');
    select.id = `attribute-${i}`;
    select.dataset.index = i;

    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = '-- Select an attribute --';
    select.appendChild(defaultOption);

    fields.forEach(field => {
      const option = document.createElement('option');
      option.value = field;
      option.textContent = field;
      select.appendChild(option);
    });

    group.appendChild(select);
    attributeSelectorsDiv.appendChild(group);
  }
}

// Generate chart based on selections
function generateChart() {
  const count = parseInt(attributeCountSelect.value);
  const selects = attributeSelectorsDiv.querySelectorAll('select');
  const selectedFields = Array.from(selects).map(s => s.value);
  const chartType = document.getElementById('chart-type').value;

  if (selectedFields.some(f => !f)) {
    errorMessage.textContent = 'Please select all attributes.';
    return;
  }

  if (!navigator.onLine) {
    errorMessage.textContent = 'Offline mode: Using demo data.';
    const demoData = generateDemoData(selectedFields);
    renderChart(demoData);
    return;
  }

  let apiUrl = `/api/data/?fields=${selectedFields.join(',')}`;
  // Removed date range parameters
  // const fromDate = document.getElementById('from-date').value;
  // const toDate = document.getElementById('to-date').value;
  // if (fromDate && toDate) {
  //   apiUrl += `&from_date=${fromDate}&to_date=${toDate}`;
  // }

  // Fetch data
  generateBtn.disabled = true;
  generateBtn.textContent = 'Loading...';
  errorMessage.textContent = '';

  fetch(apiUrl)
    .then(res => res.json())
    .then(data => {
      localStorage.setItem('lastDataset', JSON.stringify({ data, selectedFields, chartType }));
      renderChart(data);
    })
    .catch((error) => {
      errorMessage.textContent = 'Error fetching data.';
      console.error('Error fetching data:', error);
    })
    .finally(() => {
      generateBtn.disabled = false;
      generateBtn.textContent = 'Generate Visualization';
    });
}

// Render the chart
function renderChart(data) {
  const selectedFields = Array.from(document.querySelectorAll('#attribute-selectors select')).map(s => s.value);
  const chartType = document.getElementById('chart-type').value;
  // Removed date filters
  // const fromDate = document.getElementById('from-date').value;
  // const toDate = document.getElementById('to-date').value;

  // Remove date filtering logic
  // if (fromDate && toDate) {
  //   const dateFields = getPotentialDateFields(data[0]);
  //   if (dateFields.length === 0) {
  //     errorMessage.textContent = 'No date fields found in dataset.';
  //     return;
  //   }
  //   const dateField = dateFields[0];
  //   filteredData = data.filter(item => {
  //     if (!item[dateField]) return false;
  //     const dateStr = item[dateField].toString();
  //     const dateObj = new Date(dateStr);
  //     if (isNaN(dateObj.getTime())) return false;
  //     const itemDateStr = dateObj.toISOString().split('T')[0];
  //     return itemDateStr >= fromDate && itemDateStr <= toDate;
  //   });
  //   if (filteredData.length === 0) {
  //     const dateRange = getDateRange(data);
  //     errorMessage.textContent = `No data found from ${fromDate} to ${toDate}. Available dates: ${dateRange}`;
  //     return;
  //   }
  // } else {
  //   filteredData = data;
  // }

  let filteredData = data; // since no date filtering

  // Destroy previous chart if exists
  if (currentChart) currentChart.destroy();

  const ctx = chartCanvas.getContext('2d');

  let chartData;
  let xAxisTitle = '';
  let yAxisTitle = '';

  // Prepare data based on chart type and selected fields
  if (['pie', 'doughnut', 'polarArea'].includes(chartType)) {
    // Only one attribute allowed
    if (selectedFields.length > 1) {
      errorMessage.textContent = `${chartType} supports only one attribute.`;
      return;
    }
    const attr = selectedFields[0];
    const fieldData = filteredData.map(item => item[attr]);
    const labels = [...new Set(fieldData)];
    const countsMap = {};
    labels.forEach(label => {
      countsMap[label] = fieldData.filter(v => v === label).length;
    });
    const counts = Object.values(countsMap);
    chartData = {
      labels: labels,
      datasets: [{
        data: counts,
        backgroundColor: labels.map((_, i) => `hsl(${i * 360 / labels.length}, 70%, 70%)`),
        borderColor: 'rgba(0,0,0,0.05)',
        borderWidth: 1,
        label: attr
      }]
    };
    xAxisTitle = attr;
    yAxisTitle = 'Count';
  } else if (chartType === 'scatter') {
    // Exactly two attributes
    if (selectedFields.length !== 2) {
      errorMessage.textContent = 'Scatter plot requires exactly 2 attributes.';
      return;
    }
    chartData = {
      datasets: [{
        label: `${selectedFields[0]} vs ${selectedFields[1]}`,
        data: filteredData.map(item => ({
          x: parseFloat(item[selectedFields[0]]),
          y: parseFloat(item[selectedFields[1]])
        })),
        backgroundColor: 'hsla(200, 70%, 70%, 0.7)',
        borderColor: 'hsla(200, 70%, 40%, 1)',
        borderWidth: 1
      }]
    };
    xAxisTitle = selectedFields[0];
    yAxisTitle = selectedFields[1];
  } else if (selectedFields.length === 2 && ['bar', 'line'].includes(chartType)) {
    const attr1 = selectedFields[0];
    const attr2 = selectedFields[1];

    const xValues = filteredData.map(item => item[attr1]);
    const yValues = filteredData.map(item => item[attr2]);

    if (chartType === 'bar') {
      // Count occurrences for each x value
      const grouped = {};
      xValues.forEach((xVal, i) => {
        if (!grouped[xVal]) grouped[xVal] = 0;
        grouped[xVal]++;
      });
      const labels = Object.keys(grouped);
      const counts = Object.values(grouped);
      const totalCount = counts.reduce((a, b) => a + b, 0);
      const formattedLabels = labels.map(label => `${label}\nCount: ${grouped[label]}`);
      const datasetLabel = `${attr1} (Total: ${totalCount})`;
      chartData = {
        labels: formattedLabels,
        datasets: [{
          label: datasetLabel,
          data: counts,
          backgroundColor: 'hsla(200, 70%, 70%, 0.6)',
          borderColor: 'hsla(200, 70%, 40%, 1)'
        }]
      };
      xAxisTitle = attr1;
      yAxisTitle = `Count of ${attr2}`;
    } else if (chartType === 'line') {
      // Group by attr1 and count
      const groupMap = {};
      filteredData.forEach(item => {
        const key = item[attr1];
        if (!groupMap[key]) groupMap[key] = 0;
        groupMap[key]++;
      });
      const labels = Object.keys(groupMap);
      const counts = Object.values(groupMap);
      const totalCount = counts.reduce((a,b)=>a+b,0);
      const formattedLabels = labels.map(label => `${label}\nCount: ${groupMap[label]}`);
      chartData = {
        labels: formattedLabels,
        datasets: [{
          label: `${attr2} (Total: ${totalCount})`,
          data: counts,
          backgroundColor: 'hsla(200, 70%, 70%, 0.2)',
          borderColor: 'hsla(200, 70%, 40%, 1)',
          fill: false
        }]
      };
      xAxisTitle = attr1;
      yAxisTitle = attr2;
    }
  } else {
    // Default: count categories of first attribute
    const attr1 = selectedFields[0];
    const categoryValues = filteredData.map(item => item[attr1]);
    const labels = [...new Set(categoryValues)];
    const counts = labels.map(label => categoryValues.filter(v => v === label).length);
    const formattedLabels = labels.map(label => `${label}\nCount: ${counts[labels.indexOf(label)]}`);
    chartData = {
      labels: formattedLabels,
      datasets: [{
        label: `Count of ${attr1}`,
        data: counts,
        backgroundColor: labels.map((_, i) => `hsl(${i * 360 / labels.length}, 70%, 70%)`),
        borderColor: 'rgba(0,0,0,0.05)'
      }]
    };
    xAxisTitle = attr1;
    yAxisTitle = 'Count';
  }

  const chartConfig = {
    type: chartType,
    data: chartData,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 1500,
        easing: 'easeInOutQuart'
      },
      plugins: {
        title: {
          display: true,
          text: `Visualization of ${selectedFields.join(' vs ')}`,
          font: { size: 18, family: 'Orbitron' },
          color: 'black'
        },
        legend: {
          position: 'top',
          labels: {
            color: 'black',
            font: {
              family: 'Montserrat',
              size: 14
            }
          }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const chartType = context.chart.config.type;
              let label = context.label || '';
              let count = 0;

              if (['pie', 'doughnut', 'polarArea'].includes(chartType)) {
                const index = context.dataIndex;
                count = context.dataset.data[index];
              } else if (chartType === 'scatter') {
                return ''; // scatter points have different tooltip
              } else {
                count = context.dataset.data[context.dataIndex];
              }

              return `${label}\nTotal: ${count}`;
            }
          }
        }
      },
      scales: (function() {
        if (chartType === 'scatter') {
          return {
            x: {
              title: {
                display: true,
                text: xAxisTitle,
                font: { family: 'Montserrat', size: 14, weight: 'bold' },
                color: 'var(--dark-color)'
              },
              type: 'linear'
            },
            y: {
              title: {
                display: true,
                text: yAxisTitle,
                font: { family: 'Montserrat', size: 14, weight: 'bold' },
                color: 'var(--dark-color)'
              }
            }
          };
        } else {
          return {
            x: {
              title: {
                display: true,
                text: xAxisTitle,
                font: { family: 'Montserrat', size: 14, weight: 'bold' },
                color: 'var(--dark-color)'
              },
              grid: { color: 'rgba(34,38,58,0.07)' },
              ticks: {
                color: 'var(--dark-color)',
                font: { family: 'Montserrat' }
              }
            },
            y: {
              title: {
                display: true,
                text: yAxisTitle,
                font: { family: 'Montserrat', size: 14, weight: 'bold' },
                color: 'var(--dark-color)'
              },
              grid: { color: 'rgba(34,38,58,0.07)' },
              ticks: {
                color: 'var(--dark-color)',
                font: { family: 'Montserrat' }
              },
              beginAtZero: true
            }
          };
        }
      })()
    }
  };

  if (currentChart) currentChart.destroy();
  currentChart = new Chart(ctx, chartConfig);
}

// Generate demo data for offline mode
function generateDemoData(fields) {
  const demoData = [];
  const count = 15;
  for (let i=0; i<count; i++) {
    const record = {};
    fields.forEach(f => {
      const lowerF = f.toLowerCase();
      if (lowerF.includes('date')) {
        const date = new Date();
        date.setDate(date.getDate() - Math.floor(Math.random() * 30));
        record[f] = date.toISOString().split('T')[0];
      } else if (lowerF.includes('name')) {
        const names = ['X', 'Y', 'Z', 'Alpha', 'Beta'];
        record[f] = names[Math.floor(Math.random() * names.length)];
      } else if (lowerF.includes('id')) {
        record[f] = `ID-${1000 + i}`;
      } else {
        record[f] = Math.floor(Math.random() * 100) + 1;
      }
    });
    demoData.push(record);
  }
  return demoData;
}

// Event listeners
document.getElementById('attribute-count').addEventListener('change', () => {
  const count = parseInt(document.getElementById('attribute-count').value);
  renderAttributeSelectors(count);
});
document.getElementById('generate-btn').addEventListener('click', generateChart);

// Initialize attribute selectors
renderAttributeSelectors(1);
</script>
</body>
</html>